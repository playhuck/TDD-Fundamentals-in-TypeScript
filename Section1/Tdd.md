## What is TDD ?

테스트 코드는 일반적으로 프로덕션 코드를 먼저 작성한 다음 시간이 있거나 필요한 경우 Unit Tests를 작성합니다.

일반적인 Production Code를 만드는 플로우는 다음과 같습니다.

![Untitled](https://user-images.githubusercontent.com/105256335/235052429-eabb420b-7cf7-45e0-846e-02ab3757928a.png)

- **코드를 먼저 작성(Write Code) ⇒ Application(Run App)을 실행**
    
    이 단계에서 만약 앱이 실행되지 않는다면, 작성된 코드 상 문제가 존재하는 것이기 때문에 수정을 하기위해 다시 WriteCode 단계로 돌아가게 됩니다.
    
    이 단계를 통과 했다면, 추가적인 기능 추가나 수정에 따른 Code Refactor과정을 거치게 됩니다.
    
- **Refactor Code ⇒ Run App**
    
    이 단계에서 기능 추가나 수정에 따른 코드 변화를 겪고, 기능 테스트 후 앱을 실행시켰을 때나
    
    기능을 시험하는 단계에서 문제가 발생한 경우 다시, Refactor Code 단계로 돌아가
    
    서버 코드를 수정하게 됩니다.
    
    이 단계를 통과하게 되면, 작성된 코드가 실제적으로 문제없이 돌아가는지 확인하는 Test Code를 작성하게 됩니다.
    
- **Write Test ⇒ Run Test**
    
    이 단계에서는 실제적으로 작성된 코드가 내가 생각한 흐름대로 돌아가는지 확인하는 Test Code를 작성하게 됩니다.
    
    이 단계에서 생각치 못했던 플로우 상의 에러나, 문제점을 찾고 테스트 코드를 실행합니다.
    
- **Test Fails .. ?**
    
    하지만, 위와 같은 모든 단계를 거치고 난 다음과 테스트 코드 상에 문제가 없는데도 계속해서 실패한다면 내가 작성한 Code의 Logic 상의 치명적인 결함이 존재하게 됩니다.
    
    그렇다면, 이 단계에서 다시 처음의 Write Code 단계로 돌아가 다시 코드를 점검하게 됩니다.
    

Write Code 부터 Test Fails까지.. 잘 짜여지지 못한 Code에 얼마나 많은 시간을 낭비한 걸까요?

일주일, 한 달, 아니면 … Production Level에서 문제점을 찾아낸다면 1년 ?

위와 같은 프로세스의 치명적인 결함은, 이미 유기적으로 연결된 코드 간의 유지 보수가 어려워지고 시간이 더 많이 소비되는 문제점을 낳게 됩니다.

TDD는 이런 WorkFlow에서 우리를, 머리부터 꼬리까지 뒤집어 프로세스를 검증하게 합니다.

![Untitled](https://user-images.githubusercontent.com/105256335/235052510-ded6da88-0612-49ec-90ce-a34a5b66c065.png)

먼저 테스트를 작성하고, 프로덕션 코드를 작성한 다음 또 다른 테스트를 작성합니다.

그리고 다시, 프로덕션 코드를 작성… 테스트 실행 후 테스트 작성… 프로덕션 코드 작성 …

만약 테스트에 실패 했다면 내가 예상한 시나리오에 문제가 있다는 사실을 알 수 있게 됩니다.

테스트에 필요한 만큼의 코드를 작성하고, 테스트를 실행.. 이런 와 중 테스트에 통과 됐다면

해당 코드를 Refactoring할 기회가 생기게 됩니다.

따라서, 테스트가 통과되면 코드를 Refactoring하고 다시 테스트를 실행합니다.

일반적인 프로세스에서 걸리는 시간을 계산했을 때와, TDD를 적용시켜 수행한 프로세스 간의 시간은 분명한 차이를 가지고 있습니다.

또한, 모든 프로세스가 끝날 때 TDD 기반의 프로세스를 작성한 ‘나’는 누군가에게 이 코드의 신뢰에 대한 증명 가능한 무언가를 가질 수 있습니다.

그래서 **TDD는 정말로 하고 싶은 것을 증명하는 것에서 부터 시작해서 실행하는 것** 입니다.

결론적으로, 뭐가 됐든 핵심은 항상 하나입니다.

**점진적으로 작업하고, 테스트 케이스에 대한 기대치를 먼저 `증명`하는 것** 입니다.

## Why TDD ?

왜 우리는 TDD를 해야 하는가에 대한 의문은 여전히 남습니다.

이에 대한 답을 찾기 위해 3가지에 주목합니다.

1. **피드백**
    
    피드백 주기는 짧을수록 좋습니다.
    
    피드백 주기가 짧다는 것은, 더 자주 배포할 수 있고 위험을 줄일 수 있다는 소리와 같습니다.
    
    이미 Amazon과 같은 유수의 대기업에서 지속적 배포와 함께 움직이는, 짧은 피드백 주기의 강력함에 대한 성공 사례와 함께 뒷받침되고 있습니다. 
    
    하나의 팀에서 프로젝트를 진행할 때, 인력은 한정되있습니다.
    
    한정된 인력으로 시간을 줄이기 위해선, 더 짧고 더 자주 배포하고 의견을 나눠야 하며
    
    더 일찍 보여줄 수 있도록 노력해야 합니다.
    
    사실 특정 인원이 자신이 만든 코드를 배포하지 못하는 이유는 근본적으로, 자신의 코드에 확실성이 없기 때문에 모든 것이 제대로 작동하지 않는 다는 불안감에 있습니다.
    
    많은 수동 테스트가 수반되는 프로세스라면, 기능을 테스트 하는데만 수 많은 시간들이 소요됩니다. 이런 비효율을 제거하고, 자주 배포하고 안정된 운영을 위해 모든 것이 제대로 작동하도록 만들기 위해 무엇을 할 수 있을까요?
    
    가장 좋은 방법 중 하나는 일반적인 단위 테스트 또는 테스트의 자동화된 제품군을 사용하는 것 입니다.
    
    그리고 이런 테스트에서 가장 신뢰할 수 있는 이론은 TDD입니다.
    
    이런 일련의 과정들을 통해, 실패하는 이유를 확인하고 작동할 수 있다는 확신으로 배포를 통해 짧은 피드백 주기를 유지하면서 생산성을 올릴 수 있습니다.
    
2. **자신감**
    
    테스트 외에도 TDD는 두 가지 큰 이점이 더 있습니다.
    
    바로, 테스트 가능한 설계와 Refactoring을 촉진 시킴으로서 코드의 품질을 높이고 자신감을 강화하는 것 입니다.
    
    신뢰할 수 있고 빠르게 실행할 수 있는 자동화된 테스트 모음은 신뢰의 열쇠입니다.
    
    품질이 낮은 코드는, 빨리 만들어 결과물을 내야할 때 필연적으로 발생하게 됩니다.
    
    낮은 품질의 코드는 또 다른 낮은 품질의 코드를 양산하고 이런 악순환을 끊기 위해서는 코드를 수정하고 테스트 코드를 작성해야 합니다.
    
    만약, TDD 기반으로 설립된 코드에서는 어떨까요?
    
    올바르게 작성된 TDD 기반의 코드들은 신뢰할 수 있고, 빠르게 실행할 수 있는 고품질 테스트를 가지고 있다면 코드 품질을 개선해야 할 때 테스트를 실행 후 실패하면 다시
    
    코드를 정리하고 이런.. 과정이 충분히 코드가 깨끗해 질 때까지 진행 후 리팩토링 과정을 거칩니다.
    
3. **코드 작성**
    
    다음은 많은 코드를 읽는 것인데, 특히 기존 코드 베이스에서 작업하는 경우 더욱 그렇습니다.
    
    그리고 마지막으로 코드 작성입니다.
    
    이제 이러한 다양한 활동에 소요되는 시간을 모두 세어보면 다음과 같습니다.
    
    사고, 문제 해결 및 코드 읽기에 코드를 작성하는 것보다 훨씬 더 많은 시간이 소요된다는 것을 알 수 있습니다.
    
    코드.
    
    코드를 잃어버려서 다시 작성해야 했던 경험이 있다면 다음과 같은 이유로 이런 경험을 해보셨을 것입니다.
    
    일반적으로 처음에 비해 두 번째로 코드를 작성하는 것이 훨씬 빠르기 때문입니다.
    
    이는 문제 해결을 위한 사고 과정을 거쳤고 이미 모든 독서를 마쳤기 때문입니다.
    
    코드가 어디에 들어가야 하는지 파악했기 때문입니다.
    
    그리고 평가 코드 부분을 살펴보자면, 코드 작성의 상당 부분을 차지합니다,
    
    전체 시간의 대부분은 아니지만, 일종의 코드 작성 디버그에서 디버깅하는 데 소비됩니다.
    
    루프에서 무엇이 잘못되었는지 파악하고 코드를 작동 상태로 만들기 위해 디버깅하는 데 소비됩니다.
    
    하지만 이 두 가지 작업의 결과는 무엇일까요?
    
    사고와 문제 해결, 코드 읽기의 결과물은 무엇일까요?
    
    우리가 가장 많은 시간을 할애하는 활동은 무엇일까요?
    
    운이 좋으면 문서가 읽힐 수도 있고 읽히지 않을 수도 있지만, 보통은 생각입니다.
    
    생각입니다.
    
    그리고 TDD를 하면 이제 이 두 가지 활동에 대한 새로운 유형의 결과물, 즉 테스트 작성이라는 결과물을 얻게 됩니다.
    
    그리고 이는 사람들이 흔히 고려하지 않는 부분입니다.
    
    테스트를 작성하는 데 더 많은 시간이 소요될 것이라고 생각하는 경우가 많습니다.
    
    코드 작성에 소요되는 시간보다 테스트 작성에 더 많은 시간이 소요될 것으로 예상하기 때문입니다.
    
    하지만 실제로는 사고와 문제 해결에 실제로 소요되는 시간, 그리고
    
    코드 읽기 시간입니다.
    
    그리고 생각과 문제 해결, 문서화하기 위한 테스트 작성, 코드 읽기가 반복되는 루프를 설정하면 됩니다.
    
    그 문제 해결을 문서화하는 테스트를 작성하고, 테스트를 해결한 다음 다시 사고와 문제 해결로 돌아갑니다.
    
    다시 돌아갑니다.
    
    이는 사고와 문제 해결에 대한 결과물입니다.
    
    코드 작성 활동의 결과물이 아닙니다.
    
    그리고 사람들이 깨닫지 못하는 또 다른 이점은 디버깅이 필요하다는 것입니다.
    
    훨씬 덜 필요합니다.
    
    디버깅은 코드 작성 활동에서 이루어지기 때문에 코드 작성에 더 많은 시간을 할애할 수 있습니다.
    
    코드.
    
    이런 일이 일어나는 이유는 사고력과 문제 해결 활동을 더 많이 사용하기 때문입니다.
    
    효과적으로 사용하고 있기 때문입니다.
    
    단순히 생각과 기억에 그치지 않고 결과물로서 쓰기 테스트를 하는 것은 매우 강력한 힘을 발휘합니다,
    
    테스트를 작성하면 해결하고자 하는 문제를 코딩하고 이를
    
    더 작은 덩어리로 코딩하게 되므로 본질적으로 덜 막히게 됩니다.
    

요약하면 빠른 피드백을 받는 데 도움이 되므로 읽고 싶은 것입니다.

그것은 당신에게 높은 자신감을 주고 환상적인 사고 도구이며 당신은 이 모든 것을 줄일 수 있습니다.

위험, 더 많은 배포, 테스트 가능한 코드 리팩토링, 고품질 코드, 더 많은 코딩 시간, 더 적은 디버깅.
